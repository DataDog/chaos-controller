// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2026 Datadog, Inc.

package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// HeaderChecker validates and inserts license headers
type HeaderChecker struct {
	filesModified bool
}

// OffsetReason documents why a particular offset was chosen
type OffsetReason string

const (
	OffsetReasonNone             OffsetReason = "none"
	OffsetReasonShebang          OffsetReason = "shebang"
	OffsetReasonShebangAndCookie OffsetReason = "shebang_and_encoding"
	OffsetReasonBuildTags        OffsetReason = "build_tags"
	OffsetReasonAutoGenerated    OffsetReason = "auto_generated"
)

// OffsetResult contains offset value and reason
type OffsetResult struct {
	Offset  int
	Reason  OffsetReason
	Details string // Human-readable explanation
}

// OffsetStrategy defines interface for offset calculation strategies
type OffsetStrategy interface {
	Matches(lines []string) bool
	Calculate(lines []string) OffsetResult
}

// FileStructure represents the parsed structure of a file
type FileStructure struct {
	PrefixLines      []string // Lines before header (shebangs, build tags, etc.)
	HeaderLines      []string // Existing header lines (if any)
	ContentLines     []string // Rest of file content
	HeaderStartPos   int      // Where header starts (or should start)
	HeaderEndPos     int      // Where header ends (if it exists)
	HasLicenseHeader bool     // Whether existing license header detected
	NeedsBlankLine   bool     // Whether blank line needed after prefix
}

// ShebangOffsetStrategy handles shebang lines and encoding cookies
type ShebangOffsetStrategy struct {
	checker *HeaderChecker
}

func (s *ShebangOffsetStrategy) Matches(lines []string) bool {
	if len(lines) == 0 {
		return false
	}

	firstLine := lines[0]
	if !strings.HasSuffix(firstLine, "\n") {
		firstLine += "\n"
	}

	return strings.HasPrefix(firstLine, getShebangPattern())
}

func (s *ShebangOffsetStrategy) Calculate(lines []string) OffsetResult {
	// Check if line 2 has a Python encoding cookie (PEP 263)
	if len(lines) > 1 && s.checker.hasEncodingCookie(lines[1]) {
		return OffsetResult{
			Offset:  2,
			Reason:  OffsetReasonShebangAndCookie,
			Details: "Shebang on line 1, encoding cookie on line 2",
		}
	}

	return OffsetResult{
		Offset:  1,
		Reason:  OffsetReasonShebang,
		Details: "Shebang on line 1",
	}
}

// BuildTagOffsetStrategy handles Go build tags (//go:build and // +build)
type BuildTagOffsetStrategy struct{}

func (s *BuildTagOffsetStrategy) Matches(lines []string) bool {
	if len(lines) == 0 {
		return false
	}

	trimmedFirstLine := strings.TrimSpace(lines[0])

	return strings.HasPrefix(trimmedFirstLine, "//go:build")
}

func (s *BuildTagOffsetStrategy) Calculate(lines []string) OffsetResult {
	// Typical structure:
	// Line 0: //go:build ...
	// Line 1: // +build ... (optional old-style)
	// Line 2: blank line (REQUIRED by Go spec)
	blankLineIdx := 1
	if len(lines) > 1 && strings.HasPrefix(strings.TrimSpace(lines[1]), "// +build") {
		blankLineIdx = 2
	}

	// Check if the expected blank line position has a blank line
	if len(lines) > blankLineIdx && strings.TrimSpace(lines[blankLineIdx]) == "" {
		return OffsetResult{
			Offset:  blankLineIdx + 1,
			Reason:  OffsetReasonBuildTags,
			Details: fmt.Sprintf("Build tags with blank line at position %d", blankLineIdx),
		}
	}

	// If no blank line found, return position right after the last build tag
	if len(lines) > 1 && strings.HasPrefix(strings.TrimSpace(lines[1]), "// +build") {
		return OffsetResult{
			Offset:  2,
			Reason:  OffsetReasonBuildTags,
			Details: "Build tags without blank line (will need separator)",
		}
	}

	return OffsetResult{
		Offset:  1,
		Reason:  OffsetReasonBuildTags,
		Details: "Single build tag without blank line (will need separator)",
	}
}

// AutoGeneratedOffsetStrategy handles auto-generated markers
type AutoGeneratedOffsetStrategy struct{}

func (s *AutoGeneratedOffsetStrategy) Matches(lines []string) bool {
	if len(lines) == 0 {
		return false
	}

	firstLine := lines[0]
	if !strings.HasSuffix(firstLine, "\n") {
		firstLine += "\n"
	}

	for _, pattern := range getAutoGeneratedPatterns() {
		// Skip //go:build patterns since they're handled by BuildTagOffsetStrategy
		if strings.HasPrefix(pattern, "//go:build") {
			continue
		}

		if firstLine == pattern {
			return true
		}
	}

	return false
}

func (s *AutoGeneratedOffsetStrategy) Calculate(lines []string) OffsetResult {
	return OffsetResult{
		Offset:  2,
		Reason:  OffsetReasonAutoGenerated,
		Details: "Auto-generated marker on line 1",
	}
}

// NewHeaderChecker creates a new HeaderChecker instance
func NewHeaderChecker() *HeaderChecker {
	return &HeaderChecker{
		filesModified: false,
	}
}

// GenerateHeader creates the license header lines for the given comment character
func (hc *HeaderChecker) GenerateHeader(commentChar string) []string {
	return []string{
		commentChar + " Unless explicitly stated otherwise all files in this repository are licensed",
		commentChar + " under the Apache License Version 2.0.",
		commentChar + " This product includes software developed at Datadog (https://www.datadoghq.com/).",
		commentChar + " Copyright 2026 Datadog, Inc.",
		"",
	}
}

// ShouldSkipFile checks if the file is in the skip list
func (hc *HeaderChecker) ShouldSkipFile(path string) bool {
	for _, skipPath := range getFilesToSkip() {
		if path == skipPath {
			return true
		}
	}

	return false
}

// ShouldSkipDirectory checks if the directory is in the exclusion list
func (hc *HeaderChecker) ShouldSkipDirectory(dirName string) bool {
	for _, skipDir := range getDirectoriesToSkip() {
		if dirName == skipDir {
			return true
		}
	}

	return false
}

// GetHeaderOffsetWithReason returns the line offset for header insertion with explanation
func (hc *HeaderChecker) GetHeaderOffsetWithReason(lines []string) OffsetResult {
	if len(lines) == 0 {
		return OffsetResult{Offset: 0, Reason: OffsetReasonNone, Details: "Empty file"}
	}

	// Try strategies in priority order
	strategies := []OffsetStrategy{
		&ShebangOffsetStrategy{checker: hc},
		&BuildTagOffsetStrategy{},
		&AutoGeneratedOffsetStrategy{},
	}

	for _, strategy := range strategies {
		if strategy.Matches(lines) {
			return strategy.Calculate(lines)
		}
	}

	return OffsetResult{Offset: 0, Reason: OffsetReasonNone, Details: "No special structure"}
}

// GetHeaderOffset returns the line offset for header insertion
// Returns 2 if the file starts with a shebang AND has an encoding cookie on line 2
// Returns 1 if the file starts with a shebang (to preserve it)
// Returns 3 if the file has build tags (//go:build) followed by a blank line
// Returns 2 if the file has an auto-generated marker without a blank line
// Returns 0 otherwise
func (hc *HeaderChecker) GetHeaderOffset(lines []string) int {
	result := hc.GetHeaderOffsetWithReason(lines)
	return result.Offset
}

// hasEncodingCookie checks if a line contains a Python PEP 263 encoding declaration
// Examples: "# -*- coding: utf-8 -*-", "# coding: utf-8", "# coding=utf-8"
func (hc *HeaderChecker) hasEncodingCookie(line string) bool {
	trimmed := strings.TrimSpace(line)
	// Must start with # to be a comment
	if !strings.HasPrefix(trimmed, "#") {
		return false
	}

	// Check for encoding patterns
	for _, pattern := range getEncodingPatterns() {
		if strings.Contains(trimmed, pattern) {
			return true
		}
	}

	return false
}

// readFileLines reads the first maxLines lines from a file
func (hc *HeaderChecker) readFileLines(path string, maxLines int) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %s: %w", path, err)
	}

	defer func() {
		_ = file.Close()
	}()

	scanner := bufio.NewScanner(file)

	var lines []string

	for scanner.Scan() {
		lines = append(lines, scanner.Text())
		if len(lines) >= maxLines {
			break
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	return lines, nil
}

// validateBuildTags checks if build tags have the required blank line after them
// Returns true if validation passes (either no build tags or properly formatted)
func (hc *HeaderChecker) validateBuildTags(lines []string) bool {
	if len(lines) == 0 {
		return true
	}

	trimmedFirstLine := strings.TrimSpace(lines[0])
	if !strings.HasPrefix(trimmedFirstLine, "//go:build") {
		return true // No build tags, validation passes
	}

	// Found build tags, determine the last build tag line
	lastBuildTagLine := 0
	if len(lines) > 1 && strings.HasPrefix(strings.TrimSpace(lines[1]), "// +build") {
		lastBuildTagLine = 1
	}

	// Check for required blank line after build tags
	blankLineIdx := lastBuildTagLine + 1
	if len(lines) <= blankLineIdx || strings.TrimSpace(lines[blankLineIdx]) != "" {
		return false // Missing required blank line
	}

	return true
}

// compareHeaders compares the expected header with actual file content at the given position
func (hc *HeaderChecker) compareHeaders(lines []string, expectedHeader []string, startPos int) bool {
	endPos := startPos + len(expectedHeader)

	if len(lines) < endPos {
		return false // Not enough lines
	}

	// Compare each line of the header
	for i, expectedLine := range expectedHeader {
		actualLine := ""
		if startPos+i < len(lines) {
			actualLine = lines[startPos+i]
		}

		if expectedLine != actualLine {
			return false // Header mismatch
		}
	}

	return true
}

// CheckHeader reads the file and checks if it has the correct header
// Returns true if the header is correct, false if it needs to be inserted/updated
func (hc *HeaderChecker) CheckHeader(path string, commentChar string) (bool, error) {
	// Read first few lines of the file
	lines, err := hc.readFileLines(path, 10)
	if err != nil {
		return false, err
	}

	if len(lines) == 0 {
		return false, nil // Empty file needs header
	}

	// Validate build tags have proper formatting
	if !hc.validateBuildTags(lines) {
		return false, nil // Build tags missing required blank line
	}

	// Determine header position based on file structure
	offset := hc.GetHeaderOffset(lines)

	// Generate expected header
	expectedHeader := hc.GenerateHeader(commentChar)

	// Compare actual header with expected
	return hc.compareHeaders(lines, expectedHeader, offset), nil
}

// ParseFileStructure analyzes file content and returns structured representation
func (hc *HeaderChecker) ParseFileStructure(lines []string, commentChar string) *FileStructure {
	structure := &FileStructure{
		PrefixLines:      []string{},
		HeaderLines:      []string{},
		ContentLines:     []string{},
		HeaderStartPos:   0,
		HeaderEndPos:     0,
		HasLicenseHeader: false,
		NeedsBlankLine:   false,
	}

	// Determine offset based on file structure
	offsetResult := hc.GetHeaderOffsetWithReason(lines)
	structure.HeaderStartPos = offsetResult.Offset

	// Extract prefix lines (shebangs, build tags, etc.)
	if offsetResult.Offset > 0 {
		structure.PrefixLines = lines[:offsetResult.Offset]

		// Check if we need a blank line after preserved content
		if offsetResult.Offset <= len(lines) {
			lastPreservedLine := strings.TrimSpace(lines[offsetResult.Offset-1])
			nextLine := ""

			if offsetResult.Offset < len(lines) {
				nextLine = strings.TrimSpace(lines[offsetResult.Offset])
			}

			structure.NeedsBlankLine = hc.NeedsBlankLineSeparator(lastPreservedLine, nextLine)
		}
	}

	// Detect existing license header
	detection := hc.DetectExistingLicenseHeader(lines, structure.HeaderStartPos, commentChar)
	structure.HasLicenseHeader = detection.Found
	structure.HeaderEndPos = detection.EndPos

	if detection.Found {
		structure.HeaderLines = lines[structure.HeaderStartPos:detection.EndPos]
		structure.ContentLines = lines[detection.EndPos:]
	} else {
		structure.ContentLines = lines[structure.HeaderStartPos:]
	}

	return structure
}

// HeaderDetectionResult contains the result of license header detection
type HeaderDetectionResult struct {
	Found  bool
	EndPos int
}

// DetectExistingLicenseHeader searches for existing Apache license header markers
func (hc *HeaderChecker) DetectExistingLicenseHeader(lines []string, startPos int, commentChar string) HeaderDetectionResult {
	result := HeaderDetectionResult{Found: false, EndPos: startPos}

	// First, check if there's actually a license header present
	hasLicenseHeader := false

	for i := startPos; i < len(lines) && i < startPos+10; i++ {
		line := strings.TrimSpace(lines[i])
		if strings.Contains(line, "Unless explicitly stated otherwise") ||
			strings.Contains(line, "Apache License Version 2.0") ||
			strings.Contains(line, "Apache License, Version 2.0") {
			hasLicenseHeader = true
			break
		}
	}

	// Only if we found license header text, find its end position
	if hasLicenseHeader {
		result.Found = true

		for i := startPos; i < len(lines) && i < startPos+10; i++ {
			line := strings.TrimSpace(lines[i])
			// Stop if we hit a blank line after some content, or non-comment line
			if line == "" {
				result.EndPos = i + 1 // Include the blank line
				break
			}
			// Check if line starts with comment character
			if strings.HasPrefix(line, commentChar) {
				result.EndPos = i + 1
			} else {
				// Hit a non-comment line, stop here
				break
			}
		}
	}

	return result
}

// NeedsBlankLineSeparator checks if blank line needed after preserved content (build tags)
func (hc *HeaderChecker) NeedsBlankLineSeparator(lastPreservedLine string, nextLine string) bool {
	// If the last preserved line is a build tag and the next line is not blank,
	// add a blank line separator as required by Go spec
	return (strings.HasPrefix(lastPreservedLine, "//go:build") ||
		strings.HasPrefix(lastPreservedLine, "// +build")) &&
		nextLine != ""
}

// ReconstructFileContent assembles final file content with header
func (hc *HeaderChecker) ReconstructFileContent(structure *FileStructure, headerLines []string) []string {
	var result []string

	// 1. Add prefix lines (shebangs, build tags, etc.)
	if len(structure.PrefixLines) > 0 {
		result = append(result, structure.PrefixLines...)

		// 2. Add blank line separator if needed
		if structure.NeedsBlankLine {
			result = append(result, "")
		}
	}

	// 3. Add header
	result = append(result, headerLines...)

	// 4. Add rest of content
	result = append(result, structure.ContentLines...)

	return result
}

// InsertHeader replaces or inserts the license header in the file
func (hc *HeaderChecker) InsertHeader(path string, commentChar string) error {
	// 1. Read file
	content, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %w", path, err)
	}

	lines := strings.Split(string(content), "\n")
	if len(lines) > 0 && lines[len(lines)-1] == "" {
		lines = lines[:len(lines)-1] // Remove trailing empty line from split
	}

	// 2. Parse file structure
	structure := hc.ParseFileStructure(lines, commentChar)

	// 3. Generate correct header
	headerLines := hc.GenerateHeader(commentChar)

	// 4. Reconstruct file content
	result := hc.ReconstructFileContent(structure, headerLines)

	// 5. Write back to file
	newContent := strings.Join(result, "\n") + "\n"
	if err := os.WriteFile(path, []byte(newContent), 0600); err != nil {
		return fmt.Errorf("failed to write file %s: %w", path, err)
	}

	return nil
}

// ProcessFile checks and potentially updates a single file
func (hc *HeaderChecker) ProcessFile(path string) error {
	ext := filepath.Ext(path)
	commentChar, ok := getFileExtensions()[ext]

	if !ok {
		return nil // Skip files with unsupported extensions
	}

	// Check if file should be skipped
	if hc.ShouldSkipFile(path) {
		return nil
	}

	// Check if header is correct
	headerCorrect, err := hc.CheckHeader(path, commentChar)
	if err != nil {
		return err
	}

	if !headerCorrect {
		fmt.Printf("header missing in %s\n", path)

		if err := hc.InsertHeader(path, commentChar); err != nil {
			return err
		}

		hc.filesModified = true
	}

	return nil
}

// Run executes the header checker on all relevant files in the repository
func (hc *HeaderChecker) Run() (bool, error) {
	// Get file extensions configuration
	fileExtensions := getFileExtensions()

	// Collect all files to process
	var filesToProcess []string

	for ext := range fileExtensions {
		pattern := "**/*" + ext

		matches, err := filepath.Glob(pattern)
		if err != nil {
			return false, fmt.Errorf("failed to glob pattern %s: %w", pattern, err)
		}

		filesToProcess = append(filesToProcess, matches...)
	}

	// Walk the directory tree for more thorough file discovery
	err := filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip configured directories
		if d.IsDir() && hc.ShouldSkipDirectory(d.Name()) {
			return filepath.SkipDir
		}

		if d.IsDir() {
			return nil
		}

		ext := filepath.Ext(path)
		if _, ok := fileExtensions[ext]; ok {
			// Check if already in list
			found := false

			for _, existing := range filesToProcess {
				if existing == path {
					found = true
					break
				}
			}

			if !found {
				filesToProcess = append(filesToProcess, path)
			}
		}

		return nil
	})
	if err != nil {
		return false, fmt.Errorf("failed to walk directory: %w", err)
	}

	// Sort files for consistent order
	sort.Strings(filesToProcess)

	// Process each file
	for _, path := range filesToProcess {
		if err := hc.ProcessFile(path); err != nil {
			return false, fmt.Errorf("error processing %s: %w", path, err)
		}
	}

	return hc.filesModified, nil
}
