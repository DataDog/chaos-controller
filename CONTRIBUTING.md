# Contributing

This document explains how to install and run the project on a local minikube cluster.

## Requirements

To get started, we need to have the following software installed:

* [docker](https://docs.docker.com/get-docker/)
* [minikube](https://kubernetes.io/docs/tasks/tools/install-minikube/)
* [golangci-lint](https://github.com/golangci/golangci-lint)

This project is based on kubebuilder, please make sure the [listed](https://book.kubebuilder.io/quick-start.html#prerequisites) requirements for kubebuilder are installed as well.

## Deploy the controller locally

### Quick start

Install the [requirements](#requirements) for this project, then run the following commands:

* start minikube with containerd engine
  * `make minikube-start`
* build the new image of the controller with your local changes
  * `make docker-build`
* deploy the CRD and the controller on the minikube cluster
  * `kubectl create ns chaos-engineering`
  * `make install`

If the controller is already deployed and you want to test a new version of it, please run the `make restart` command.

The [samples](config/samples) contains sample data which can be used to test your changes.

* [demo.yaml](config/samples/demo.yaml) contains a bunch of testing resources you can apply directly to your cluster
  * `kubectl -n chaos-engineering apply -f config/samples/demo.yaml`

### Helpers scripts

For verification on minikube we created some helper [scripts](scripts/):

* List contents of iptables for the given pod:
  * `./scripts/list_iptables.sh <pod_name>`
* List pod interfaces:
  * `./scripts/list_links.sh <pod_name>`
* List traffic control filters of the given pod:
  * `./scripts/list_tc_filters.sh <pod_name>`
* List traffic control qdiscs of the given pod:
  * `./scripts/list_tc_qdiscs.sh <pod_name>`

## Minikube ISO

See [minikube_image.md](docs/minikube_image.md)

## Re-generating the CRD manifest

When the API package is changed, the CRD (custom resource definition) must be re-generated. To achieve that, just run the `make manifests` command.

## 3rd-party licenses

3rd-party references and licenses are kept in the [LICENSE-3rdparty.csv](LICENSE-3rdparty.csv) file. This file has been generated by the [tasks/3rdparty.py](tasks/3rdparty.py) script. If any vendor is updated, added or removed, this file must be updated as well.

## Available commands

### Running, installing & generating

* `make generate`: generate boilerplate code.
* `make install`: install CRDs and controller into a cluster
* `make manifests`: generate manifests e.g. CRD, RBAC etc.
* `make run`: run against the configured Kubernetes cluster in ~/.kube/config
* `make uninstall`: uninstall CRDs and controller from a cluster
* `make restart`: restart the controller

### Building

* `make docker-build`: build both images and load them into minikube
  * `make docker-build-injector`: build the injector image and load it into minikube
  * `make docker-build-manager`: build the manager image and load it into minikube
* `make injector`: build injector binary
* `make manager`: build manager binary
* `make minikube-start`: start minikube with our ISO and containerd runtime

### Testing, checking & linting

* `make fmt`: run go fmt against the codebase.
* `make header-check`: check all files if they contain the correct header.
* `make license-check`: check if all third party modules contain a license and build the license database.
* `make lint`: run golangci-lint against codebase.
* `make test`: run tests
* `make vet`: run go vet against the codebase.

## Release

Releasing a new version of the project is pretty simple: just push a new tag!

```
git tag -a X.Y.Z
git push --follow-tags origin master
```

It'll trigger a bunch of [GitHub Actions](https://github.com/DataDog/chaos-controller/blob/master/.github/workflows/release.yml) that will:

* create a new release
  * build both controller and injector binaries for linux amd64
  * archive them with license related files
  * create a release with a generated changelog and uploaded files
* update the changelog
  * generate the changelog
  * push it to a new branch
  * open a PR for you to approve the changes
