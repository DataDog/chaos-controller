# Contributing

This document explains how to install and run the project on a local minikube cluster.

## Signing commits using `gpg`

* Download gpg [here](https://gnupg.org/download/)
* [Generating a new `gpg` key](https://docs.github.com/en/github/authenticating-to-github/managing-commit-signature-verification/generating-a-new-gpg-key)
* [Add `gpg` key to your GitHub account](https://docs.github.com/en/github/authenticating-to-github/managing-commit-signature-verification/adding-a-new-gpg-key-to-your-github-account)
* [Tell git about your signing key](https://docs.github.com/en/github/authenticating-to-github/managing-commit-signature-verification/telling-git-about-your-signing-key)
* [Automatically sign all commits](https://docs.github.com/en/github/authenticating-to-github/managing-commit-signature-verification/signing-commits)

## Requirements

To get started, we need to have the following software installed:

* [docker](https://docs.docker.com/get-docker/)
* [minikube](https://kubernetes.io/docs/tasks/tools/install-minikube/) (1: Installation)
* [golangci-lint](https://github.com/golangci/golangci-lint)
* [Kubebuilder Prerequisites](https://book.kubebuilder.io/quick-start.html#prerequisites) (go, docker, kubectl, kubebuilder, controller-gen)
* [helm](https://helm.sh/docs/intro/quickstart/)

# Deploy the controller locally

## Quick start

Once you have installed the above requirements, run the following commands:

* start minikube with containerd engine
  * `make minikube-start`
* deploy cert-manager
  * `kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.3.0/cert-manager.yaml`
* build the new image of the controller with your local changes
  * `make minikube-build`
* deploy the CRD and the controller on the minikube cluster
  * `make install`

If the controller is already deployed and you want to test a new version of it, please run the `make restart` command.

The [samples](examples/) contains sample data which can be used to test your changes.

* [demo.yaml](examples/demo.yaml) contains a bunch of testing resources you can apply directly to your cluster
  * `kubectl create ns chaos-engineering`
  * `kubectl -n chaos-engineering apply -f examples/demo.yaml`

## Helpers scripts

For verification on minikube we created some helper [scripts](scripts/):

* List pod interfaces:
  * `./scripts/list_links.sh <pod_name>`
* List traffic control filters of the given pod:
  * `./scripts/list_tc_filters.sh <pod_name>`
* List traffic control qdiscs of the given pod:
  * `./scripts/list_tc_qdiscs.sh <pod_name>`

## Minikube ISO

See [minikube_image.md](docs/minikube_image.md)

## Re-generating the CRD manifest

When the API package is changed, the CRD (custom resource definition) must be re-generated. To achieve that, just run the `make manifests` command.

## 3rd-party licenses

3rd-party references and licenses are kept in the [LICENSE-3rdparty.csv](LICENSE-3rdparty.csv) file. This file has been generated by the [tasks/3rdparty.py](tasks/3rdparty.py) script. If any vendor is updated, added or removed, this file must be updated as well.

## Available commands

### Running, installing & generating

* `make generate`: generate boilerplate code.
* `make install`: install CRDs and controller into a cluster
* `make manifests`: generate manifests e.g. CRD, RBAC etc.
* `make uninstall`: uninstall CRDs and controller from a cluster
* `make restart`: restart the controller

### Building

* `make minikube-build`: build both images and load them into minikube
  * `make minikube-build-injector`: build the injector image and load it into minikube
  * `make minikube-build-manager`: build the manager image and load it into minikube
* `make injector`: build injector binary
* `make manager`: build manager binary
* `make minikube-start`: start minikube with our ISO and containerd runtime

### Testing, checking & linting

* `make fmt`: run go fmt against the codebase.
* `make header-check`: check all files if they contain the correct header.
* `make license-check`: check if all third party modules contain a license and build the license database.
* `make lint`: run golangci-lint against codebase.
* `make test`: run tests
* `make vet`: run go vet against the codebase.
