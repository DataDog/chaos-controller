# Contributing

## Testing the controller locally

More extensive documentation about testing can be found in the testing [docs](docs/testing.md)

### Quick start

Install the [required](docs/testing.md#requirements) requirements for this project first.

If you want to test the controller locally (without having to redeploy a new image on a staging cluster), please use the [minikube project](https://kubernetes.io/docs/setup/learning-environment/minikube/) as described below:

* start minikube with containerd engine
  * `make minikube-start`
* build the new image of the controller with your local changes
  * `make docker-build`
* deploy the CRD and the controller on the minikube cluster
  * `make install && make deploy`

If the controller is already deployed, you'll have to remove the running pod for changes to be applied.

The [samples](config/samples) contains sample data which can be used to test your changes.

* [deployment.yaml](config/samples/deployment.yaml) contains a simple container which can be used for testing
* [chaos_v1beta1_disruption.yaml](config/samples/chaos_v1beta1_disruption.yaml) contains a Disruption resource. Feel free to comment out want you don't need.

Both samples can be applied using kubectl: `kubectl apply -f deployment.yaml`.

### Minikube ISO

See [minikube_image.md](docs/minikube_image.md)

## Re-generating the CRD manifest

When the API package is changed, the CRD (custom resource definition) must be re-generated. To achieve that, just run the `make manifests` command.

## 3rd-party licenses

3rd-party references and licenses are kept in the [LICENSE-3rdparty.csv](LICENSE-3rdparty.csv) file. This file has been generated by the [tasks/3rdparty.py](tasks/3rdparty.py) script. If any vendor is updated, added or removed, this file must be updated as well.

## Available commands

### Running, installing & generating

* `make deploy`: deploy the controller in the configured Kubernetes cluster in ~/.kube/config
* `make generate`: generate boilerplate code.
* `make install`: install CRDs into a cluster
* `make manifests`: generate manifests e.g. CRD, RBAC etc.
* `make run`: run against the configured Kubernetes cluster in ~/.kube/config
* `make uninstall`: uninstall CRDs from a cluster

### Building

* `make docker-build`: build both images and load them into minikube
  * `make docker-build-injector`: build the injector image and load it into minikube
  * `make docker-build-manager`: build the manager image and load it into minikube
* `make injector`: build injector binary
* `make manager`: build manager binary
* `make minikube-start`: start minikube with our ISO and containerd runtime

### Testing, checking & linting

* `make fmt`: run go fmt against the codebase.
* `make header-check`: check all files if they contain the correct header.
* `make license-check`: check if all third party modules contain a license and build the license database.
* `make lint`: run golangci-lint against codebase.
* `make test`: run tests
* `make vet`: run go vet against the codebase.

## Release

Releasing a new version of the project is pretty simple: just push a new tag!

```
git tag -a X.Y.Z
git push --follow-tags origin master
```

It'll trigger a bunch of [GitHub Actions](https://github.com/DataDog/chaos-controller/blob/master/.github/workflows/release.yml) that will:

* create a new release
  * build both controller and injector binaries for linux amd64
  * archive them with license related files
  * create a release with a generated changelog and uploaded files
* update the changelog
  * generate the changelog
  * push it to a new branch
  * open a PR for you to approve the changes
